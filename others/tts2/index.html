<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Content Editable Read Aloud</title>
    <!-- Basic page styles for the demo -->
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        line-height: 1.6;
        background-color: #f8f9fa; /* Lighter page background */
        color: #202124;
        padding: 20px;
        margin: 0;
      }
      .container {
        max-width: 800px;
        margin: 20px auto;
        padding: 30px;
        background-color: #ffffff;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      }
      h1 {
        color: #111;
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
      }
      /* Style for the contenteditable div */
      #editor {
        border: 1px solid #ddd;
        padding: 15px;
        min-height: 200px;
        border-radius: 8px;
        background-color: #ffffff;
        outline: none;
        transition: box-shadow 0.2s ease;
      }
      #editor:focus {
        border-color: #1a73e8;
        box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.15);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Read Aloud Editor</h1>
      <p>Select any text inside the box below to see the "Read" toolbar.</p>
      <!-- This is the contenteditable div -->
      <div id="editor" contenteditable="true">
        <p>This is a <strong>contenteditable</strong> area. You can edit this text.</p>
        <p>
          Try selecting a portion of this sentence. The toolbar now appears in a
          minimal state. Click the "..." icon to expand it and see the Language,
          Voice, and Speed options.
        </p>
        <p>
          The toolbar's expanded/collapsed state is now saved. If you expand it,
          it will stay expanded the next time you select text.
        </p>
        <p>
          The Language list is now populated directly from your browser's
          available speech engines.
        </p>
        <ul>
          <li>Select this list item.</li>
          <li>Or this one.</li>
        </ul>
      </div>
    </div>
    <!-- Read Aloud Script (Updated) -->
    <script>
      (() => {
        const Z = 2147483647;
        const synth = window.speechSynthesis;
        const IDS = {
          style: "__rs_styles",
          layer: "rs-highlight-layer",
          toolbar: "rs-toolbar",
          readBtn: "rs-read-btn",
          langBtn: "rs-lang-btn",
          voiceBtn: "rs-voice-btn",
          rateBtn: "rs-rate-btn", // Added
          moreBtn: "rs-more-btn",
          langMenu: "rs-lang-menu",
          voiceMenu: "rs-voice-menu",
          rateMenu: "rs-rate-menu", // Added
        };
        const pref = {
          lang:
            localStorage.getItem("RS_LANG") ||
            (navigator.languages && navigator.languages[0]) ||
            navigator.language ||
            "en-US",
          voiceURI: localStorage.getItem("RS_VOICE_URI") || "",
          rate: parseFloat(localStorage.getItem("RS_RATE") || "1.0"), // Added
        };
        const EXPAND_KEY = "RS_TOOLBAR_EXPANDED";
        const VOICE_MAP_KEY = "RS_VOICE_BY_LANG";
        let baseRange = null;
        let lastText = "";
        let lastSlice = null;
        let utter = null;
        let voicesCache = [];
        let lastAnimatedTokenStart = -1;
        let isReading = !1;
        let allowToolbar = !0;
        injectStyles();
        const toolbar = ensureToolbar();
        const layer = ensureLayer();
        const langMenu = ensureMenu(IDS.langMenu);
        const voiceMenu = ensureMenu(IDS.voiceMenu);
        const rateMenu = ensureMenu(IDS.rateMenu); // Added
        toolbar.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
        langMenu.addEventListener("pointerdown", (e) => e.stopPropagation());
        voiceMenu.addEventListener("pointerdown", (e) => e.stopPropagation());
        rateMenu.addEventListener("pointerdown", (e) => e.stopPropagation()); // Added
        if (synth && typeof synth.addEventListener === "function") {
          synth.addEventListener("voiceschanged", () => {
            voicesCache = synth.getVoices();
            populateLangs();
            ensureVoiceForCurrentLang();
            populateVoices();
          });
        }
        voicesCache = synth?.getVoices?.() || [];
        populateLangs();
        ensureVoiceForCurrentLang();
        populateVoices();
        populateRates(); // Added
        document.addEventListener("pointerdown", (e) => {
          const t = e.target;
          const isToolbarClick = t.closest(`#${IDS.toolbar}`);
          const isMenuClick =
            t.closest(`.${IDS.langMenu}`) ||
            t.closest(`.${IDS.voiceMenu}`) ||
            t.closest(`.${IDS.rateMenu}`); // Modified
          if (isToolbarClick || isMenuClick) return;
          if (isReading) {
            synth.cancel();
          }
          hide(langMenu);
          hide(voiceMenu);
          hide(rateMenu); // Added
          if (!isReading) {
            allowToolbar = !1;
          }
        });
        document.addEventListener("pointerup", () => {
          if (!isReading) {
            allowToolbar = !0;
          }
          onSelectionUpdate();
        });
        document.addEventListener("mouseup", onSelectionUpdate);
        document.addEventListener("keyup", onSelectionUpdate);
        document.addEventListener("selectionchange", onSelectionUpdate);
        document.addEventListener("scroll", repaintHighlight, !0);
        document.addEventListener("click", onDocClick, !0);
        [
          IDS.readBtn,
          IDS.langBtn,
          IDS.voiceBtn,
          IDS.rateBtn,
          IDS.moreBtn,
        ].forEach((id) => { // Modified
          const el = byId(id);
          if (!el) return;
          el.addEventListener("pointerdown", (e) => {
            e.preventDefault();
            e.stopPropagation();
          });
        });
        byId(IDS.readBtn)?.addEventListener("click", () => {
          onReadClicked();
        });
        byId(IDS.moreBtn)?.addEventListener("click", (e) => {
          e.stopPropagation();
          const isExpanded = toolbar.dataset.expanded === "true";
          const newState = isExpanded ? "false" : "true";
          toolbar.dataset.expanded = newState;
          localStorage.setItem(EXPAND_KEY, newState);
          if (isExpanded) {
            hide(langMenu);
            hide(voiceMenu);
            hide(rateMenu); // Added
          }
        });
        byId(IDS.langBtn)?.addEventListener("click", (e) => {
          e.stopPropagation();
          hide(voiceMenu);
          hide(rateMenu); // Added
          toggleMenu(langMenu, byId(IDS.langBtn));
        });
        byId(IDS.voiceBtn)?.addEventListener("click", (e) => {
          e.stopPropagation();
          hide(langMenu);
          hide(rateMenu); // Added
          toggleMenu(voiceMenu, byId(IDS.voiceBtn));
        });
        byId(IDS.rateBtn)?.addEventListener("click", (e) => { // Added
          e.stopPropagation();
          hide(langMenu);
          hide(voiceMenu);
          toggleMenu(rateMenu, byId(IDS.rateBtn));
        });
        window.removeReadSelectedTools =
          function removeReadSelectedTools() {
            document.removeEventListener("mouseup", onSelectionUpdate);
            document.removeEventListener("keyup", onSelectionUpdate);
            document.removeEventListener("selectionchange", onSelectionUpdate);
            document.removeEventListener("scroll", repaintHighlight, !0);
            document.removeEventListener("click", onDocClick, !0);
            document.body.classList.remove("rs-reading");
            [
              IDS.toolbar,
              IDS.layer,
              IDS.style,
              IDS.langMenu,
              IDS.voiceMenu,
              IDS.rateMenu, // Modified
            ].forEach((id) => byId(id)?.remove());
            synth && synth.cancel();
          };
        function injectStyles() {
          if (byId(IDS.style)) return;
          const s = document.createElement("style");
          s.id = IDS.style;
          s.textContent = `
                      :root {
                        --rs-surface: #ffffff;
                        --rs-on-surface: #202124;
                        --rs-on-surface-variant: #5f6368;
                        --rs-outline: #dadce0;
                        --rs-primary: #1a73e8;
                        --rs-hover: #f1f3f4;
                        --rs-shadow: rgba(0,0,0,.15);
                        --rs-scrim: rgba(0,0,0,.4);

                        /* Highlight Colors */
                        --rs-word-bg-1: rgba(168, 203, 255, 0.7);
                        --rs-word-bg-2: rgba(168, 203, 255, 0.5);
                        --rs-word-outline: rgba(122, 168, 255, 0.8);
                      }
                      @media (prefers-color-scheme: dark) {
                        :root {
                          --rs-surface: #2d2e30; /* Darker surface */
                          --rs-on-surface: #e8eaed;
                          --rs-on-surface-variant: #bdc1c6;
                          --rs-outline: #44474a;
                          --rs-primary: #8ab4f8;
                          --rs-hover: #3a3c3e;
                          --rs-shadow: rgba(0,0,0,.3);
                          --rs-scrim: rgba(0,0,0,.6);

                          /* Dark Highlight Colors */
                          --rs-word-bg-1: rgba(138, 180, 248, .45);
                          --rs-word-bg-2: rgba(138, 180, 248, .25);
                          --rs-word-outline: rgba(138, 180, 248, .85);
                        }
                      }

                      /* Toolbar (Google Material Design) */
                      #${IDS.toolbar} {
                        position: absolute;
                        z-index: ${Z};
                        display: none; /* Hidden by default */
                        flex-direction: row;
                        align-items: center;
                        gap: 4px; /* Tighter gap */
                        padding: 6px;
                        background: var(--rs-surface);
                        border: 1px solid var(--rs-outline);
                        border-radius: 24px; /* Pill shape */
                        box-shadow: 0 4px 8px -2px var(--rs-shadow), 0 0 1px 0 var(--rs-shadow);
                        font: 13px/1.1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
                        backdrop-filter: saturate(120%) blur(6px);
                        /* UPDATED: Removed 'width' from transition */
                        transition: opacity .15s ease, transform .15s ease;
                        overflow: hidden; /* Needed for width animation */
                        white-space: nowrap; /* Prevent wrapping during animation */
                      }

                      /* Icon Button */
                      .rs-icon-btn {
                        width: 36px; height: 36px;
                        padding: 0;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        flex-shrink: 0; /* Prevent buttons from shrinking */
                        border-radius: 50%; /* Circular */
                        border: 1px solid transparent;
                        background: transparent;
                        color: var(--rs-on-surface-variant);
                        cursor: pointer;
                        user-select: none;
                        transition: background-color .15s ease, transform .2s ease;
                      }
                      .rs-icon-btn:hover {
                        background: var(--rs-hover);
                      }
                      .rs-icon-btn:active {
                        background: color-mix(in srgb, var(--rs-hover) 80%, var(--rs-scrim));
                      }
                      .rs-icon-btn svg {
                        width: 20px; height: 20px;
                      }
                      /* Read button is primary */
                      #${IDS.readBtn} {
                        color: var(--rs-primary);
                      }
                      
                      /* Read/Stop Icon Toggle */
                      #${IDS.readBtn} .rs-play-icon { display: inline-flex; }
                      #${IDS.readBtn} .rs-stop-icon { display: none; }
                      #${IDS.readBtn} .rs-spinner-icon { display: none; } /* Added */

                      #${IDS.toolbar}[data-reading="true"] #${IDS.readBtn} .rs-play-icon { display: none; }
                      #${IDS.toolbar}[data-reading="true"] #${IDS.readBtn} .rs-stop-icon { display: inline-flex; }

                      /* Added loading state */
                      #${IDS.toolbar}[data-reading="loading"] #${IDS.readBtn} .rs-play-icon { display: none; }
                      #${IDS.toolbar}[data-reading="loading"] #${IDS.readBtn} .rs-spinner-icon { 
                        display: inline-flex; 
                        animation: rsSpin 1s linear infinite;
                      }

                      .rs-divider { 
                        width: 1px; 
                        height: 24px; 
                        background: var(--rs-outline); 
                        margin: 0 2px;
                        flex-shrink: 0;
                      }
                      
                      /* Collapsible Toolbar Styles */
                      #${IDS.langBtn}, #${IDS.voiceBtn}, #${IDS.rateBtn}, #${IDS.toolbar} .rs-divider { /* Modified */
                        display: none; /* Hide by default */
                      }
                      #${IDS.toolbar}[data-expanded="true"] #${IDS.langBtn},
                      #${IDS.toolbar}[data-expanded="true"] #${IDS.voiceBtn},
                      #${IDS.toolbar}[data-expanded="true"] #${IDS.rateBtn}, /* Modified */
                      #${IDS.toolbar}[data-expanded="true"] .rs-divider {
                        display: inline-flex; /* Show when expanded */
                      }
                      
                      /* More button rotation */
                      #${IDS.toolbar}[data-expanded="true"] #${IDS.moreBtn} {
                        transform: rotate(90deg);
                      }
                      #${IDS.toolbar}[data-expanded="false"] #${IDS.moreBtn} {
                        transform: rotate(0deg);
                      }


                      /* Custom Menu */
                      .${IDS.langMenu}, .${IDS.voiceMenu}, .${IDS.rateMenu} { /* Modified */
                        position: absolute;
                        z-index: ${Z + 1};
                        display: none; /* Hidden by default */
                        background: var(--rs-surface);
                        border: 1px solid var(--rs-outline);
                        border-radius: 8px;
                        box-shadow: 0 5px 15px -3px var(--rs-shadow), 0 0 1px 0 var(--rs-shadow);
                        padding: 8px 0;
                        min-width: 200px;
                        max-height: 250px;
                        overflow-x: hidden;
                        overflow-y: auto;
                      }
                      
                      /* Menu Item */
                      .rs-menu-item {
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
                        padding: 8px 16px 8px 20px;
                        color: var(--rs-on-surface);
                        cursor: pointer;
                        user-select: none;
                        white-space: nowrap;
                      }
                      .rs-menu-item:hover {
                        background: var(--rs-hover);
                      }
                      .rs-menu-item .rs-check-icon {
                        width: 18px; height: 18px;
                        visibility: hidden; /* Hide by default */
                        color: var(--rs-primary);
                      }
                      .rs-menu-item[data-selected="true"] {
                        color: var(--rs-primary);
                        font-weight: 500;
                      }
                      .rs-menu-item[data-selected="true"] .rs-check-icon {
                        visibility: visible;
                      }

                      /* Use a light grey selection instead of transparent */
                      .rs-reading ::selection { 
                        background: rgba(0, 0, 0, 0.1); /* Light grey selection */
                        color: inherit; 
                      }
                      @media (prefers-color-scheme: dark) {
                        .rs-reading ::selection { 
                          background: rgba(255, 255, 255, 0.15); /* Light grey selection (dark) */
                          color: inherit; 
                        }
                      }
                      
                      /* Previous bounce effect (unchanged) */
                      @keyframes rsBounceIn {
                        0%   { transform: translateX(-10%) scaleX(.1); opacity: .15; }
                        55%  { transform: translateX(2%)   scaleX(1.05); opacity: .98; }
                        75%  { transform: translateX(-1%) scaleX(.98); }
                        100% { transform: translateX(0)   scaleX(1); opacity: 1; }
                      }
                      
                      /* Added spinner animation */
                      @keyframes rsSpin {
                        from { transform: rotate(0deg); }
                        to { transform: rotate(360deg); }
                      }

                      #${IDS.layer} { position: absolute; left: 0; top: 0; width: 0; height: 0; pointer-events: none; z-index: ${Z}; }
                      .rs-chunk {
                        position: absolute;
                        border-radius: 6px; /* Slightly larger radius */
                        background: linear-gradient(180deg, var(--rs-word-bg-1), var(--rs-word-bg-2));
                        outline: 1px solid var(--rs-word-outline);
                        box-shadow: 0 4px 10px var(--rs-shadow), inset 0 0 0 1px rgba(255,255,255,.06);
                        transform-origin: left center;
                      }
                      .rs-chunk--animate { animation: rsBounceIn .22s cubic-bezier(.34,1.56,.64,1); }
                    `;
          document.head.appendChild(s);
        }
        function ensureToolbar() {
          let el = byId(IDS.toolbar);
          if (el) return el;
          el = document.createElement("div");
          el.id = IDS.toolbar;
          const read = iconButton(
            svgPlay() + svgStop() + svgSpinner(), // Modified
            "Read",
            "rs-icon-btn"
          );
          read.id = IDS.readBtn;
          const moreBtn = iconButton(svgMore(), "More options", "rs-icon-btn");
          moreBtn.id = IDS.moreBtn;
          const langBtn = iconButton(svgLang(), "Language", "rs-icon-btn");
          langBtn.id = IDS.langBtn;
          const voiceBtn = iconButton(svgVoice(), "Voice", "rs-icon-btn");
          voiceBtn.id = IDS.voiceBtn;
          const rateBtn = iconButton(svgRate(), "Reading Speed", "rs-icon-btn"); // Added
          rateBtn.id = IDS.rateBtn; // Added
          const divider = document.createElement("div");
          divider.className = "rs-divider";
          el.append(read, moreBtn, divider, langBtn, voiceBtn, rateBtn); // Modified
          document.body.appendChild(el);
          return el;
        }
        function ensureMenu(id) {
          let el = byId(id);
          if (el) return el;
          el = document.createElement("div");
          el.id = id;
          el.className = id;
          document.body.appendChild(el);
          return el;
        }
        function ensureLayer() {
          let el = byId(IDS.layer);
          if (el) return el;
          el = document.createElement("div");
          el.id = IDS.layer;
          document.body.appendChild(el);
          return el;
        }
        function iconButton(iconSvg, title, cls) {
          const b = document.createElement("button");
          b.className = cls;
          b.title = title;
          b.innerHTML = iconSvg;
          return b;
        }
        function toggleMenu(menu, button) {
          if (!menu || !button) return;
          if (menu.style.display === "block") {
            hide(menu);
          } else {
            const btnRect = button.getBoundingClientRect();
            menu.style.display = "block";
            menu.style.left = `${window.scrollX + btnRect.left}px`;
            menu.style.top = `${window.scrollY + btnRect.bottom + 8}px`;
          }
        }
        function byId(id) {
          return document.getElementById(id);
        }
        function hide(el) {
          if (el) el.style.display = "none";
        }
        function populateLangs() {
          const langSet = new Set();
          (voicesCache || []).forEach((v) => langSet.add(v.lang));
          const langs = Array.from(langSet).sort((a, b) =>
            langDisplayName(String(a)).localeCompare(langDisplayName(String(b)))
          );
          const menu = byId(IDS.langMenu);
          if (!menu) return;
          menu.replaceChildren();
          const checkIcon = svgCheck();
          if (pref.lang && !langs.includes(pref.lang)) {
            langs.unshift(pref.lang);
          }
          for (const code of langs) {
            if (!code) continue;
            const item = document.createElement("div");
            item.className = "rs-menu-item";
            item.dataset.value = code;
            item.innerHTML = `<span class="rs-check-icon">${checkIcon}</span><span>${langDisplayName(
              code
            )}</span>`;
            if (code.toLowerCase() === (pref.lang || "").toLowerCase()) {
              item.dataset.selected = "true";
            }
            item.addEventListener("click", () => {
              pref.lang = code;
              localStorage.setItem("RS_LANG", pref.lang);
              if (isReading) synth.cancel();
              menu
                .querySelectorAll(".rs-menu-item")
                .forEach((el) => (el.dataset.selected = "false"));
              item.dataset.selected = "true";
              ensureVoiceForCurrentLang();
              populateVoices();
              hide(menu);
            });
            menu.appendChild(item);
          }
        }
        function ensureVoiceForCurrentLang() {
          const map = getVoiceMap();
          const saved = map[pref.lang];
          const filtered = (voicesCache || []).filter(
            (v) =>
              v.lang && v.lang.toLowerCase().startsWith(pref.lang.toLowerCase())
          );
          const langDefault = filtered.find((v) => v.default) || filtered[0] || null;
          const nextVoiceURI = saved || (langDefault ? langDefault.voiceURI : "");
          pref.voiceURI = nextVoiceURI || "";
          localStorage.setItem("RS_VOICE_URI", pref.voiceURI);
          if (nextVoiceURI) {
            map[pref.lang] = nextVoiceURI;
            setVoiceMap(map);
          }
        }
        function langDisplayName(code) {
          try {
            const [lang, region] = code.split(/[-_]/);
            const dn = hasIntlDisplayNames()
              ? new Intl.DisplayNames([pref.lang || navigator.language || "en"], {
                  type: "language",
                }).of(lang)
              : fallbackLangName(lang);
            const dr =
              region && hasIntlDisplayNames()
                ? new Intl.DisplayNames([pref.lang || navigator.language || "en"], {
                    type: "region",
                  }).of(region.toUpperCase())
                : region;
            return dr ? `${capitalize(dn)} (${dr})` : capitalize(dn);
          } catch {
            return code;
          }
        }
        function hasIntlDisplayNames() {
          return typeof Intl !== "undefined" && typeof Intl.DisplayNames === "function";
        }
        function fallbackLangName(lang) {
          const map = {
            en: "English",
            es: "Spanish",
            fr: "French",
            de: "German",
            it: "Italian",
            pt: "Portuguese",
            hi: "Hindi",
            ja: "Japanese",
            ko: "Korean",
            zh: "Chinese",
          };
          return map[lang?.toLowerCase()] || lang || "Unknown";
        }
        function capitalize(s) {
          return (s || "").slice(0, 1).toUpperCase() + (s || "").slice(1);
        }
        function populateVoices() {
          const filtered = (voicesCache || [])
            .filter(
              (v) =>
                !pref.lang ||
                (v.lang && v.lang.toLowerCase().startsWith(pref.lang.toLowerCase()))
            )
            .sort((a, b) => (a.name || "").localeCompare(b.name || ""));
          const menu = byId(IDS.voiceMenu);
          if (!menu) return;
          menu.replaceChildren();
          const checkIcon = svgCheck();
          if (!filtered.length) {
            const item = document.createElement("div");
            item.className = "rs-menu-item";
            item.style.fontStyle = "italic";
            item.style.color = "var(--rs-on-surface-variant)";
            item.textContent = "No voices for this language";
            menu.appendChild(item);
            pref.voiceURI = "";
            localStorage.setItem("RS_VOICE_URI", pref.voiceURI);
          } else {
            let currentVoiceInList = !1;
            filtered.forEach((v) => {
              const item = document.createElement("div");
              item.className = "rs-menu-item";
              item.dataset.value = v.voiceURI;
              item.innerHTML = `<span class="rs-check-icon">${checkIcon}</span><span>${
                v.name
              } (${v.lang})${v.default ? " - Default" : ""}</span>`;
              if (v.voiceURI === pref.voiceURI) {
                item.dataset.selected = "true";
                currentVoiceInList = !0;
              }
              item.addEventListener("click", () => {
                pref.voiceURI = v.voiceURI;
                localStorage.setItem("RS_VOICE_URI", pref.voiceURI);
                if (isReading) synth.cancel();
                const map = getVoiceMap();
                map[pref.lang] = v.voiceURI;
                setVoiceMap(map);
                menu
                  .querySelectorAll(".rs-menu-item")
                  .forEach((el) => (el.dataset.selected = "false"));
                item.dataset.selected = "true";
                hide(menu);
              });
              menu.appendChild(item);
            });
            if (!currentVoiceInList && menu.children.length > 0) {
              const firstItem = menu.children[0];
              if (firstItem && firstItem.classList.contains("rs-menu-item")) {
                firstItem.dataset.selected = "true";
                const firstVoiceURI = firstItem.dataset.value || "";
                pref.voiceURI = firstVoiceURI;
                localStorage.setItem("RS_VOICE_URI", pref.voiceURI);
                const map = getVoiceMap();
                if (pref.lang) map[pref.lang] = firstVoiceURI;
                setVoiceMap(map);
              }
            }
          }
        }
        function getVoiceMap() {
          try {
            return JSON.parse(localStorage.getItem(VOICE_MAP_KEY) || "{}") || {};
          } catch {
            return {};
          }
        }
        function setVoiceMap(obj) {
          try {
            localStorage.setItem(VOICE_MAP_KEY, JSON.stringify(obj));
          } catch {}
        }
        function onSelectionUpdate() {
          if (isReading || !allowToolbar) return;
          hide(langMenu);
          hide(voiceMenu);
          hide(rateMenu); // Added
          const info = getSelectionInfo();
          const tb = byId(IDS.toolbar);
          if (!tb) return;
          if (!info) {
            hide(tb);
            return;
          }
          tb.style.display = "inline-flex";
          tb.dataset.expanded = localStorage.getItem(EXPAND_KEY) || "false";
          requestAnimationFrame(() => {
            const tbHeight = tb.offsetHeight;
            const tbWidth = tb.offsetWidth;
            let left =
              window.scrollX + info.rect.left + info.rect.width / 2 - tbWidth / 2;
            left = Math.max(
              window.scrollX + 10,
              Math.min(
                left,
                window.scrollX + document.documentElement.clientWidth - tbWidth - 10
              )
            );
            let top = window.scrollY + info.rect.top - tbHeight - 10;
            if (top < window.scrollY + 10) {
              top = window.scrollY + info.rect.bottom + 10;
            }
            tb.style.left = `${left}px`;
            tb.style.top = `${top}px`;
          });
        }
        function onDocClick(e) {
          if (isReading) return;
          const t = e.target;
          if (
            t.closest(`#${IDS.toolbar}`) ||
            t.closest(`.${IDS.langMenu}`) ||
            t.closest(`.${IDS.voiceMenu}`) ||
            t.closest(`.${IDS.rateMenu}`) // Added
          )
            return;
          const sel = window.getSelection();
          if (!sel || sel.isCollapsed) {
            hide(byId(IDS.toolbar));
            hide(langMenu);
            hide(voiceMenu);
            hide(rateMenu); // Added
          }
        }
        function getSelectionInfo() {
          const sel = window.getSelection();
          if (!sel || sel.isCollapsed) return null;
          const text = String(sel).trim();
          if (!text) return null;
          try {
            const range = sel.getRangeAt(0);
            let rect = range.getBoundingClientRect();
            if (!rect || (rect.width === 0 && rect.height === 0)) {
              const el = document.activeElement;
              if (el && "selectionStart" in el) rect = el.getBoundingClientRect();
            }
            return { text, rect: rect, range: range.cloneRange() };
          } catch {
            return null;
          }
        }
        function textNodesInRange(range) {
          const nodes = [];
          const tw = document.createTreeWalker(
            range.commonAncestorContainer,
            NodeFilter.SHOW_TEXT,
            {
              acceptNode: (n) => {
                const nr = document.createRange();
                try {
                  nr.selectNodeContents(n);
                } catch {
                  return NodeFilter.FILTER_REJECT;
                }
                const cmpStart =
                  nr.compareBoundaryPoints(Range.END_TO_START, range) <= 0;
                const cmpEnd =
                  nr.compareBoundaryPoints(Range.START_TO_END, range) >= 0;
                return cmpStart && cmpEnd
                  ? NodeFilter.FILTER_ACCEPT
                  : NodeFilter.FILTER_REJECT;
              },
            }
          );
          let n;
          while ((n = tw.nextNode())) {
            const start = n === range.startContainer ? range.startOffset : 0;
            const end =
              n === range.endContainer ? range.endOffset : n.nodeValue.length;
            if (end > start)
              nodes.push({ node: n, start, end, len: end - start });
          }
          return nodes;
        }
        function buildSliceMap(base) {
          const parts = textNodesInRange(base);
          const map = [];
          let acc = 0;
          for (const p of parts) {
            map.push({
              node: p.node,
              start: p.start,
              end: p.end,
              len: p.len,
              accStart: acc,
            });
            acc += p.len;
          }
          const total = acc;
          const text = map.map((m) => m.node.nodeValue.slice(m.start, m.end)).join("");
          return { map, total, text };
        }
        function makeSubRangeFromSlice(base, sliceStart, sliceLen) {
          const { map, total } = buildSliceMap(base);
          const clampedStart = Math.max(0, Math.min(sliceStart, total));
          const clampedEnd = Math.max(
            clampedStart,
            Math.min(sliceStart + sliceLen, total)
          );
          const sub = document.createRange();
          let i = 0,
            pos = clampedStart;
          while (i < map.length && map[i].accStart + map[i].len <= pos) i++;
          if (i >= map.length) return null;
          const mStart = map[i];
          const startOffsetInNode = mStart.start + (pos - mStart.accStart);
          sub.setStart(mStart.node, startOffsetInNode);
          let j = i,
            posEnd = clampedEnd;
          while (j < map.length && map[j].accStart + map[j].len < posEnd) j++;
          const mEnd = map[j] || map[map.length - 1];
          const endOffsetInNode = mEnd.start + (posEnd - mEnd.accStart);
          sub.setEnd(mEnd.node, endOffsetInNode);
          return sub;
        }
        function repaintHighlight() {
          if (!baseRange || !lastSlice) return;
          const sub = makeSubRangeFromSlice(
            baseRange,
            lastSlice.start,
            lastSlice.length
          );
          if (sub) drawRange(sub, !1);
        }
        function drawRange(r, animate) {
          const host = byId(IDS.layer);
          if (!host) return;
          host.replaceChildren();
          const PAD = 4;
          const rects = Array.from(r.getClientRects ? r.getClientRects() : []);
          rects.forEach((rc, i) => {
            const d = document.createElement("div");
            d.className = "rs-chunk" + (animate ? " rs-chunk--animate" : "");
            Object.assign(d.style, {
              left: `${window.scrollX + rc.left - PAD}px`,
              top: `${window.scrollY + rc.top - PAD}px`,
              width: `${rc.width + PAD * 2}px`,
              height: `${rc.height + PAD * 2}px`,
              animationDelay: animate ? `${i * 0.02}s` : "0s",
            });
            host.appendChild(d);
          });
        }
        function getTokenAt(text, index) {
          if (!text) return { start: 0, length: 0 };
          let s = index,
            e = index;
          while (s > 0 && /\S/.test(text[s - 1])) s--;
          while (e < text.length && /\S/.test(text[e])) e++;
          return { start: s, length: Math.max(0, e - s) };
        }
        function onReadClicked() {
          // Modified check to include loading state
          if (isReading || toolbar.dataset.reading === "loading") {
            synth.cancel();
            return;
          }
          const info = getSelectionInfo();
          if (!info) return;
          if (!synth) {
            return;
          }
          hide(langMenu);
          hide(voiceMenu);
          hide(rateMenu); // Added
          allowToolbar = !1;
          synth.cancel();
          byId(IDS.layer)?.replaceChildren();
          document.body.classList.add("rs-reading");
          
          toolbar.dataset.reading = "loading"; // Set to loading
          
          baseRange = info.range;
          const built = buildSliceMap(baseRange);
          lastText = built.text;
          lastAnimatedTokenStart = -1;
          utter = new SpeechSynthesisUtterance(built.text);
          utter.rate = pref.rate; // Modified
          utter.pitch = 1;
          utter.volume = 1;
          if (pref.lang) utter.lang = pref.lang;
          const chosenVoice =
            (voicesCache || []).find((v) => v.voiceURI === pref.voiceURI) ||
            (voicesCache || []).find(
              (v) =>
                v.lang &&
                pref.lang &&
                v.lang.toLowerCase().startsWith(pref.lang.toLowerCase())
            );
          if (chosenVoice) utter.voice = chosenVoice;

          // NEW: onstart handler
          utter.onstart = () => {
            isReading = !0; // Set isReading to true only when speech actually starts
            toolbar.dataset.reading = "true";
          };

          utter.onend = utter.onerror = () => {
            lastSlice = null;
            byId(IDS.layer)?.replaceChildren();
            document.body.classList.remove("rs-reading");
            isReading = !1; // Reset isReading
            toolbar.dataset.reading = "false"; // Reset to play icon
            allowToolbar = !0;
            onSelectionUpdate();
          };
          utter.onboundary = (e) => { // Modified
            const idx = typeof e.charIndex === "number" ? e.charIndex : null;
            if (idx == null) return;
            const tok = getTokenAt(lastText, idx);
            const isNewToken = tok.start !== lastAnimatedTokenStart;
            if (!/\S/.test(lastText[idx] || "")) return;
            let len = e.charLength;
            if (!len || len <= 0) len = tok.length || 1;
            lastAnimatedTokenStart = tok.start;
            lastSlice = { start: tok.start, length: len };
            const sub = makeSubRangeFromSlice(baseRange, tok.start, len);
            if (sub) drawRange(sub, isNewToken);
            if (isNewToken && tok.length > 0) { // Added console log
              const word = lastText.substring(tok.start, tok.start + tok.length);
              console.log("Reading:", word);
            }
          };
          synth.speak(utter);
        }
        function unique(list) {
          const seen = new Set();
          return list.filter((v) => {
            const k = String(v || "").toLowerCase();
            if (seen.has(k) || !k) return !1;
            seen.add(k);
            return !0;
          });
        }
        // Added function
        function populateRates() {
          const rates = [0.5, 0.75, 1.0, 1.25, 1.5, 2.0];
          const menu = byId(IDS.rateMenu);
          if (!menu) return;
          menu.replaceChildren();
          const checkIcon = svgCheck();
          for (const rate of rates) {
            const item = document.createElement("div");
            item.className = "rs-menu-item";
            item.dataset.value = rate;
            item.innerHTML = `<span class="rs-check-icon">${checkIcon}</span><span>${rate.toFixed(
              2
            )}x</span>`;
            if (rate === pref.rate) {
              item.dataset.selected = "true";
            }
            item.addEventListener("click", () => {
              pref.rate = rate;
              localStorage.setItem("RS_RATE", pref.rate);
              if (isReading) {
                synth.cancel();
                onReadClicked();
              } // Restart reading with new rate
              menu
                .querySelectorAll(".rs-menu-item")
                .forEach((el) => (el.dataset.selected = "false"));
              item.dataset.selected = "true";
              hide(menu);
            });
            menu.appendChild(item);
          }
        }
        // Added function
        function svgRate() {
          return `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M15 1H9v2h6V1zm-4 13h2V8h-2v6zm8.03-6.61l1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61zM12 20c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/></svg>`;
        }
        function svgPlay() {
          return `<svg class="rs-play-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M8 5v14l11-7-11-7z"/></svg>`;
        }
        function svgStop() {
          return `<svg class="rs-stop-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M6 6h12v12H6z"/></svg>`;
        }
        function svgLang() {
          return `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v2h11.17c-.7 2.36-1.95 4.5-3.71 6.53l-.03.03-2.54 2.51L1 18.07l2.12 2.12 6.4-6.4 2.54-2.51 6.4 6.4L23 18.07l-3.72-3.72-2.54 2.51zM10 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>`;
        }
        function svgVoice() {
          return `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1.2-9.1c0-.66.54-1.2 1.2-1.2s1.2.54 1.2 1.2l-.01 6.2c0 .66-.53 1.2-1.19 1.2s-1.2-.54-1.2-1.2V4.9zm6.5 6.1c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg>`;
        }
        function svgCheck() {
          return `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></svg>`;
        }
        function svgMore() {
          return `<svg class="rs-more-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></svg>`;
        }
        // Added function
        function svgSpinner() {
          return `<svg class="rs-spinner-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <line x1="12" y1="2" x2="12" y2="6"></line>
            <line x1="12" y1="18" x2="12" y2="22"></line>
            <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
            <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
            <line x1="2" y1="12" x2="6" y2="12"></line>
            <line x1="18" y1="12" x2="22" y2="12"></line>
            <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line>
            <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>
          </svg>`;
        }
      })();
    </script>
  </body>
</html>